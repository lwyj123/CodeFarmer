(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.CodeFlask = factory());
}(this, (function () { 'use strict';

  const BACKGROUND_COLOR = '#fff';
  const LINE_HEIGHT = '20px';
  const FONT_SIZE = '13px';

  const default_css_theme = `
.codeflask {
  background: ${BACKGROUND_COLOR};
  color: #4f559c;
}

.codeflask .token.punctuation {
  color: #4a4a4a;
}

.codeflask .token.keyword {
  color: #8500ff;
}

.codeflask .token.operator {
  color: #ff5598;
}

.codeflask .token.string {
  color: #41ad8f;
}

.codeflask .token.comment {
  color: #9badb7;
}

.codeflask .token.function {
  color: #8500ff;
}

.codeflask .token.boolean {
  color: #8500ff;
}

.codeflask .token.number {
  color: #8500ff;
}

.codeflask .token.selector {
  color: #8500ff;
}

.codeflask .token.property {
  color: #8500ff;
}

.codeflask .token.tag {
  color: #8500ff;
}

.codeflask .token.attr-value {
  color: #8500ff;
}
`;

  const FONT_FAMILY = `"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace`;
  const COLOR = (CSS.supports('caret-color', '#000')) ? BACKGROUND_COLOR : '#ccc';
  const LINE_NUMBER_WIDTH = '40px';


  const editor_css = `
  .codeflask {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .codeflask, .codeflask * {
    box-sizing: border-box;
  }

  .codeflask__pre {
    pointer-events: none;
    z-index: 3;
    overflow: hidden;
  }

  .codeflask__textarea {
    background: none;
    border: none;
    color: ${COLOR};
    z-index: 1;
    resize: none;
    font-family: ${FONT_FAMILY};
    -webkit-appearance: pre;
    caret-color: #111;
    z-index: 2;
    width: 100%;
    height: 100%;
  }

  .codeflask--has-line-numbers .codeflask__textarea {
    width: calc(100% - ${LINE_NUMBER_WIDTH});
  }

  .codeflask__code {
    display: block;
    font-family: ${FONT_FAMILY};
    overflow: hidden;
  }

  .codeflask__flatten {
    padding: 10px;
    font-size: ${FONT_SIZE};
    line-height: ${LINE_HEIGHT};
    white-space: pre;
    position: absolute;
    top: 0;
    left: 0;
    overflow: auto;
    margin: 0 !important;
    outline: none;
    text-align: left;
  }

  .codeflask--has-line-numbers .codeflask__flatten {
    width: calc(100% - ${LINE_NUMBER_WIDTH});
    left: ${LINE_NUMBER_WIDTH};
  }

  .codeflask__line-highlight {
    position: absolute;
    top: 10px;
    left: 0;
    width: 100%;
    height: ${LINE_HEIGHT};
    background: rgba(0,0,0,0.1);
    z-index: 1;
  }

  .codeflask__lines {
    padding: 10px 4px;
    font-size: 12px;
    line-height: ${LINE_HEIGHT};
    font-family: 'Cousine', monospace;
    position: absolute;
    left: 0;
    top: 0;
    width: ${LINE_NUMBER_WIDTH};
    height: 100%;
    text-align: right;
    color: #999;
    z-index: 2;
  }

  .codeflask__lines__line {
    display: block;
  }

  .codeflask.codeflask--has-line-numbers {
    padding-left: ${LINE_NUMBER_WIDTH};
  }

  .codeflask.codeflask--has-line-numbers:before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: ${LINE_NUMBER_WIDTH};
    height: 100%;
    background: #eee;
    z-index: 1;
  }
`;

  function inject_css(css, styleName, parent) {
    const CSS_ID = styleName || 'codeflask-style';
    const PARENT = parent || document.head;

    if (!css) {
      return false;
    }

    if (document.getElementById(CSS_ID)) {
      return true;
    }

    const style = document.createElement('style');

    style.innerHTML = css;
    style.id = CSS_ID;
    PARENT.appendChild(style);

    return true;
  }

  const entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escape_html (string) {
    return String(string).replace(/[&<>"'`=\/]/g, function (s) {
      return entityMap[s];
    });
  }

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var prism = createCommonjsModule(function (module) {
  /* **********************************************
       Begin prism-core.js
  ********************************************** */

  var _self = (typeof window !== 'undefined')
  	? window   // if in browser
  	: (
  		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
  		? self // if in worker
  		: {}   // if in node js
  	);

  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   * MIT license http://www.opensource.org/licenses/mit-license.php/
   * @author Lea Verou http://lea.verou.me
   */

  var Prism = (function(){

  // Private helper vars
  var lang = /\blang(?:uage)?-([\w-]+)\b/i;
  var uniqueId = 0;

  var _ = _self.Prism = {
  	manual: _self.Prism && _self.Prism.manual,
  	disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
  	util: {
  		encode: function (tokens) {
  			if (tokens instanceof Token) {
  				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
  			} else if (_.util.type(tokens) === 'Array') {
  				return tokens.map(_.util.encode);
  			} else {
  				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
  			}
  		},

  		type: function (o) {
  			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
  		},

  		objId: function (obj) {
  			if (!obj['__id']) {
  				Object.defineProperty(obj, '__id', { value: ++uniqueId });
  			}
  			return obj['__id'];
  		},

  		// Deep clone a language definition (e.g. to extend it)
  		clone: function (o, visited) {
  			var type = _.util.type(o);
  			visited = visited || {};

  			switch (type) {
  				case 'Object':
  					if (visited[_.util.objId(o)]) {
  						return visited[_.util.objId(o)];
  					}
  					var clone = {};
  					visited[_.util.objId(o)] = clone;

  					for (var key in o) {
  						if (o.hasOwnProperty(key)) {
  							clone[key] = _.util.clone(o[key], visited);
  						}
  					}

  					return clone;

  				case 'Array':
  					if (visited[_.util.objId(o)]) {
  						return visited[_.util.objId(o)];
  					}
  					var clone = [];
  					visited[_.util.objId(o)] = clone;

  					o.forEach(function (v, i) {
  						clone[i] = _.util.clone(v, visited);
  					});

  					return clone;
  			}

  			return o;
  		}
  	},

  	languages: {
  		extend: function (id, redef) {
  			var lang = _.util.clone(_.languages[id]);

  			for (var key in redef) {
  				lang[key] = redef[key];
  			}

  			return lang;
  		},

  		/**
  		 * Insert a token before another token in a language literal
  		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
  		 * we cannot just provide an object, we need anobject and a key.
  		 * @param inside The key (or language id) of the parent
  		 * @param before The key to insert before. If not provided, the function appends instead.
  		 * @param insert Object with the key/value pairs to insert
  		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
  		 */
  		insertBefore: function (inside, before, insert, root) {
  			root = root || _.languages;
  			var grammar = root[inside];

  			if (arguments.length == 2) {
  				insert = arguments[1];

  				for (var newToken in insert) {
  					if (insert.hasOwnProperty(newToken)) {
  						grammar[newToken] = insert[newToken];
  					}
  				}

  				return grammar;
  			}

  			var ret = {};

  			for (var token in grammar) {

  				if (grammar.hasOwnProperty(token)) {

  					if (token == before) {

  						for (var newToken in insert) {

  							if (insert.hasOwnProperty(newToken)) {
  								ret[newToken] = insert[newToken];
  							}
  						}
  					}

  					ret[token] = grammar[token];
  				}
  			}

  			// Update references in other language definitions
  			_.languages.DFS(_.languages, function(key, value) {
  				if (value === root[inside] && key != inside) {
  					this[key] = ret;
  				}
  			});

  			return root[inside] = ret;
  		},

  		// Traverse a language definition with Depth First Search
  		DFS: function(o, callback, type, visited) {
  			visited = visited || {};
  			for (var i in o) {
  				if (o.hasOwnProperty(i)) {
  					callback.call(o, i, o[i], type || i);

  					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
  						visited[_.util.objId(o[i])] = true;
  						_.languages.DFS(o[i], callback, null, visited);
  					}
  					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
  						visited[_.util.objId(o[i])] = true;
  						_.languages.DFS(o[i], callback, i, visited);
  					}
  				}
  			}
  		}
  	},
  	plugins: {},

  	highlightAll: function(async, callback) {
  		_.highlightAllUnder(document, async, callback);
  	},

  	highlightAllUnder: function(container, async, callback) {
  		var env = {
  			callback: callback,
  			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
  		};

  		_.hooks.run("before-highlightall", env);

  		var elements = env.elements || container.querySelectorAll(env.selector);

  		for (var i=0, element; element = elements[i++];) {
  			_.highlightElement(element, async === true, env.callback);
  		}
  	},

  	highlightElement: function(element, async, callback) {
  		// Find language
  		var language, grammar, parent = element;

  		while (parent && !lang.test(parent.className)) {
  			parent = parent.parentNode;
  		}

  		if (parent) {
  			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
  			grammar = _.languages[language];
  		}

  		// Set language on the element, if not present
  		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

  		if (element.parentNode) {
  			// Set language on the parent, for styling
  			parent = element.parentNode;

  			if (/pre/i.test(parent.nodeName)) {
  				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
  			}
  		}

  		var code = element.textContent;

  		var env = {
  			element: element,
  			language: language,
  			grammar: grammar,
  			code: code
  		};

  		_.hooks.run('before-sanity-check', env);

  		if (!env.code || !env.grammar) {
  			if (env.code) {
  				_.hooks.run('before-highlight', env);
  				env.element.textContent = env.code;
  				_.hooks.run('after-highlight', env);
  			}
  			_.hooks.run('complete', env);
  			return;
  		}

  		_.hooks.run('before-highlight', env);

  		if (async && _self.Worker) {
  			var worker = new Worker(_.filename);

  			worker.onmessage = function(evt) {
  				env.highlightedCode = evt.data;

  				_.hooks.run('before-insert', env);

  				env.element.innerHTML = env.highlightedCode;

  				callback && callback.call(env.element);
  				_.hooks.run('after-highlight', env);
  				_.hooks.run('complete', env);
  			};

  			worker.postMessage(JSON.stringify({
  				language: env.language,
  				code: env.code,
  				immediateClose: true
  			}));
  		}
  		else {
  			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

  			_.hooks.run('before-insert', env);

  			env.element.innerHTML = env.highlightedCode;

  			callback && callback.call(element);

  			_.hooks.run('after-highlight', env);
  			_.hooks.run('complete', env);
  		}
  	},

  	highlight: function (text, grammar, language) {
  		var env = {
  			code: text,
  			grammar: grammar,
  			language: language
  		};
  		_.hooks.run('before-tokenize', env);
  		env.tokens = _.tokenize(env.code, env.grammar);
  		_.hooks.run('after-tokenize', env);
  		return Token.stringify(_.util.encode(env.tokens), env.language);
  	},

  	matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {
  		var Token = _.Token;

  		for (var token in grammar) {
  			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
  				continue;
  			}

  			if (token == target) {
  				return;
  			}

  			var patterns = grammar[token];
  			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

  			for (var j = 0; j < patterns.length; ++j) {
  				var pattern = patterns[j],
  					inside = pattern.inside,
  					lookbehind = !!pattern.lookbehind,
  					greedy = !!pattern.greedy,
  					lookbehindLength = 0,
  					alias = pattern.alias;

  				if (greedy && !pattern.pattern.global) {
  					// Without the global flag, lastIndex won't work
  					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
  					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
  				}

  				pattern = pattern.pattern || pattern;

  				// Don’t cache length as it changes during the loop
  				for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {

  					var str = strarr[i];

  					if (strarr.length > text.length) {
  						// Something went terribly wrong, ABORT, ABORT!
  						return;
  					}

  					if (str instanceof Token) {
  						continue;
  					}

  					if (greedy && i != strarr.length - 1) {
  						pattern.lastIndex = pos;
  						var match = pattern.exec(text);
  						if (!match) {
  							break;
  						}

  						var from = match.index + (lookbehind ? match[1].length : 0),
  						    to = match.index + match[0].length,
  						    k = i,
  						    p = pos;

  						for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {
  							p += strarr[k].length;
  							// Move the index i to the element in strarr that is closest to from
  							if (from >= p) {
  								++i;
  								pos = p;
  							}
  						}

  						// If strarr[i] is a Token, then the match starts inside another Token, which is invalid
  						if (strarr[i] instanceof Token) {
  							continue;
  						}

  						// Number of tokens to delete and replace with the new match
  						delNum = k - i;
  						str = text.slice(pos, p);
  						match.index -= pos;
  					} else {
  						pattern.lastIndex = 0;

  						var match = pattern.exec(str),
  							delNum = 1;
  					}

  					if (!match) {
  						if (oneshot) {
  							break;
  						}

  						continue;
  					}

  					if(lookbehind) {
  						lookbehindLength = match[1] ? match[1].length : 0;
  					}

  					var from = match.index + lookbehindLength,
  					    match = match[0].slice(lookbehindLength),
  					    to = from + match.length,
  					    before = str.slice(0, from),
  					    after = str.slice(to);

  					var args = [i, delNum];

  					if (before) {
  						++i;
  						pos += before.length;
  						args.push(before);
  					}

  					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

  					args.push(wrapped);

  					if (after) {
  						args.push(after);
  					}

  					Array.prototype.splice.apply(strarr, args);

  					if (delNum != 1)
  						_.matchGrammar(text, strarr, grammar, i, pos, true, token);

  					if (oneshot)
  						break;
  				}
  			}
  		}
  	},

  	tokenize: function(text, grammar, language) {
  		var strarr = [text];

  		var rest = grammar.rest;

  		if (rest) {
  			for (var token in rest) {
  				grammar[token] = rest[token];
  			}

  			delete grammar.rest;
  		}

  		_.matchGrammar(text, strarr, grammar, 0, 0, false);

  		return strarr;
  	},

  	hooks: {
  		all: {},

  		add: function (name, callback) {
  			var hooks = _.hooks.all;

  			hooks[name] = hooks[name] || [];

  			hooks[name].push(callback);
  		},

  		run: function (name, env) {
  			var callbacks = _.hooks.all[name];

  			if (!callbacks || !callbacks.length) {
  				return;
  			}

  			for (var i=0, callback; callback = callbacks[i++];) {
  				callback(env);
  			}
  		}
  	}
  };

  var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
  	this.type = type;
  	this.content = content;
  	this.alias = alias;
  	// Copy of the full string this token was created from
  	this.length = (matchedStr || "").length|0;
  	this.greedy = !!greedy;
  };

  Token.stringify = function(o, language, parent) {
  	if (typeof o == 'string') {
  		return o;
  	}

  	if (_.util.type(o) === 'Array') {
  		return o.map(function(element) {
  			return Token.stringify(element, language, o);
  		}).join('');
  	}

  	var env = {
  		type: o.type,
  		content: Token.stringify(o.content, language, parent),
  		tag: 'span',
  		classes: ['token', o.type],
  		attributes: {},
  		language: language,
  		parent: parent
  	};

  	if (o.alias) {
  		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
  		Array.prototype.push.apply(env.classes, aliases);
  	}

  	_.hooks.run('wrap', env);

  	var attributes = Object.keys(env.attributes).map(function(name) {
  		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
  	}).join(' ');

  	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

  };

  if (!_self.document) {
  	if (!_self.addEventListener) {
  		// in Node.js
  		return _self.Prism;
  	}

  	if (!_.disableWorkerMessageHandler) {
  		// In worker
  		_self.addEventListener('message', function (evt) {
  			var message = JSON.parse(evt.data),
  				lang = message.language,
  				code = message.code,
  				immediateClose = message.immediateClose;

  			_self.postMessage(_.highlight(code, _.languages[lang], lang));
  			if (immediateClose) {
  				_self.close();
  			}
  		}, false);
  	}

  	return _self.Prism;
  }

  //Get current script and highlight
  var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

  if (script) {
  	_.filename = script.src;

  	if (!_.manual && !script.hasAttribute('data-manual')) {
  		if(document.readyState !== "loading") {
  			if (window.requestAnimationFrame) {
  				window.requestAnimationFrame(_.highlightAll);
  			} else {
  				window.setTimeout(_.highlightAll, 16);
  			}
  		}
  		else {
  			document.addEventListener('DOMContentLoaded', _.highlightAll);
  		}
  	}
  }

  return _self.Prism;

  })();

  if (module.exports) {
  	module.exports = Prism;
  }

  // hack for components to work correctly in node.js
  if (typeof commonjsGlobal !== 'undefined') {
  	commonjsGlobal.Prism = Prism;
  }


  /* **********************************************
       Begin prism-markup.js
  ********************************************** */

  Prism.languages.markup = {
  	'comment': /<!--[\s\S]*?-->/,
  	'prolog': /<\?[\s\S]+?\?>/,
  	'doctype': /<!DOCTYPE[\s\S]+?>/i,
  	'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
  	'tag': {
  		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,
  		greedy: true,
  		inside: {
  			'tag': {
  				pattern: /^<\/?[^\s>\/]+/i,
  				inside: {
  					'punctuation': /^<\/?/,
  					'namespace': /^[^\s>\/:]+:/
  				}
  			},
  			'attr-value': {
  				pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,
  				inside: {
  					'punctuation': [
  						/^=/,
  						{
  							pattern: /(^|[^\\])["']/,
  							lookbehind: true
  						}
  					]
  				}
  			},
  			'punctuation': /\/?>/,
  			'attr-name': {
  				pattern: /[^\s>\/]+/,
  				inside: {
  					'namespace': /^[^\s>\/:]+:/
  				}
  			}

  		}
  	},
  	'entity': /&#?[\da-z]{1,8};/i
  };

  Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
  	Prism.languages.markup['entity'];

  // Plugin to make entity title show the real entity, idea by Roman Komarov
  Prism.hooks.add('wrap', function(env) {

  	if (env.type === 'entity') {
  		env.attributes['title'] = env.content.replace(/&amp;/, '&');
  	}
  });

  Prism.languages.xml = Prism.languages.markup;
  Prism.languages.html = Prism.languages.markup;
  Prism.languages.mathml = Prism.languages.markup;
  Prism.languages.svg = Prism.languages.markup;


  /* **********************************************
       Begin prism-css.js
  ********************************************** */

  Prism.languages.css = {
  	'comment': /\/\*[\s\S]*?\*\//,
  	'atrule': {
  		pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i,
  		inside: {
  			'rule': /@[\w-]+/
  			// See rest below
  		}
  	},
  	'url': /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
  	'selector': /[^{}\s][^{};]*?(?=\s*\{)/,
  	'string': {
  		pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
  		greedy: true
  	},
  	'property': /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
  	'important': /\B!important\b/i,
  	'function': /[-a-z0-9]+(?=\()/i,
  	'punctuation': /[(){};:]/
  };

  Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

  if (Prism.languages.markup) {
  	Prism.languages.insertBefore('markup', 'tag', {
  		'style': {
  			pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,
  			lookbehind: true,
  			inside: Prism.languages.css,
  			alias: 'language-css',
  			greedy: true
  		}
  	});

  	Prism.languages.insertBefore('inside', 'attr-value', {
  		'style-attr': {
  			pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
  			inside: {
  				'attr-name': {
  					pattern: /^\s*style/i,
  					inside: Prism.languages.markup.tag.inside
  				},
  				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
  				'attr-value': {
  					pattern: /.+/i,
  					inside: Prism.languages.css
  				}
  			},
  			alias: 'language-css'
  		}
  	}, Prism.languages.markup.tag);
  }

  /* **********************************************
       Begin prism-clike.js
  ********************************************** */

  Prism.languages.clike = {
  	'comment': [
  		{
  			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
  			lookbehind: true
  		},
  		{
  			pattern: /(^|[^\\:])\/\/.*/,
  			lookbehind: true,
  			greedy: true
  		}
  	],
  	'string': {
  		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
  		greedy: true
  	},
  	'class-name': {
  		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
  		lookbehind: true,
  		inside: {
  			punctuation: /[.\\]/
  		}
  	},
  	'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
  	'boolean': /\b(?:true|false)\b/,
  	'function': /[a-z0-9_]+(?=\()/i,
  	'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
  	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
  	'punctuation': /[{}[\];(),.:]/
  };


  /* **********************************************
       Begin prism-javascript.js
  ********************************************** */

  Prism.languages.javascript = Prism.languages.extend('clike', {
  	'keyword': /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
  	'number': /\b(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
  	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  	'function': /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\()/i,
  	'operator': /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
  });

  Prism.languages.insertBefore('javascript', 'keyword', {
  	'regex': {
  		pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[[^\]\r\n]+]|\\.|[^/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})\]]))/,
  		lookbehind: true,
  		greedy: true
  	},
  	// This must be declared before keyword because we use "function" inside the look-forward
  	'function-variable': {
  		pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i,
  		alias: 'function'
  	},
  	'constant': /\b[A-Z][A-Z\d_]*\b/
  });

  Prism.languages.insertBefore('javascript', 'string', {
  	'template-string': {
  		pattern: /`(?:\\[\s\S]|\${[^}]+}|[^\\`])*`/,
  		greedy: true,
  		inside: {
  			'interpolation': {
  				pattern: /\${[^}]+}/,
  				inside: {
  					'interpolation-punctuation': {
  						pattern: /^\${|}$/,
  						alias: 'punctuation'
  					},
  					rest: null // See below
  				}
  			},
  			'string': /[\s\S]+/
  		}
  	}
  });
  Prism.languages.javascript['template-string'].inside['interpolation'].inside.rest = Prism.languages.javascript;

  if (Prism.languages.markup) {
  	Prism.languages.insertBefore('markup', 'tag', {
  		'script': {
  			pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
  			lookbehind: true,
  			inside: Prism.languages.javascript,
  			alias: 'language-javascript',
  			greedy: true
  		}
  	});
  }

  Prism.languages.js = Prism.languages.javascript;


  /* **********************************************
       Begin prism-file-highlight.js
  ********************************************** */

  (function () {
  	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
  		return;
  	}

  	self.Prism.fileHighlight = function() {

  		var Extensions = {
  			'js': 'javascript',
  			'py': 'python',
  			'rb': 'ruby',
  			'ps1': 'powershell',
  			'psm1': 'powershell',
  			'sh': 'bash',
  			'bat': 'batch',
  			'h': 'c',
  			'tex': 'latex'
  		};

  		Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
  			var src = pre.getAttribute('data-src');

  			var language, parent = pre;
  			var lang = /\blang(?:uage)?-([\w-]+)\b/i;
  			while (parent && !lang.test(parent.className)) {
  				parent = parent.parentNode;
  			}

  			if (parent) {
  				language = (pre.className.match(lang) || [, ''])[1];
  			}

  			if (!language) {
  				var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
  				language = Extensions[extension] || extension;
  			}

  			var code = document.createElement('code');
  			code.className = 'language-' + language;

  			pre.textContent = '';

  			code.textContent = 'Loading…';

  			pre.appendChild(code);

  			var xhr = new XMLHttpRequest();

  			xhr.open('GET', src, true);

  			xhr.onreadystatechange = function () {
  				if (xhr.readyState == 4) {

  					if (xhr.status < 400 && xhr.responseText) {
  						code.textContent = xhr.responseText;

  						Prism.highlightElement(code);
  					}
  					else if (xhr.status >= 400) {
  						code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
  					}
  					else {
  						code.textContent = '✖ Error: File does not exist or is empty';
  					}
  				}
  			};

  			xhr.send(null);
  		});

  		if (Prism.plugins.toolbar) {
  			Prism.plugins.toolbar.registerButton('download-file', function (env) {
  				var pre = env.element.parentNode;
  				if (!pre || !/pre/i.test(pre.nodeName) || !pre.hasAttribute('data-src') || !pre.hasAttribute('data-download-link')) {
  					return;
  				}
  				var src = pre.getAttribute('data-src');
  				var a = document.createElement('a');
  				a.textContent = pre.getAttribute('data-download-link-label') || 'Download';
  				a.setAttribute('download', '');
  				a.href = src;
  				return a;
  			});
  		}

  	};

  	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

  })();
  });

  class CodeFlask {
    constructor(selectorOrElement, opts) {
      if (!selectorOrElement) {
        // If no selector or element is passed to CodeFlask,
        // stop execution and throw error.
        throw Error('CodeFlask expects a parameter which is Element or a String selector');
        return;
      }

      if (!opts) {
        // If no selector or element is passed to CodeFlask,
        // stop execution and throw error.
        throw Error('CodeFlask expects an object containing options as second parameter');
        return;
      }

      if (selectorOrElement.nodeType) {
        // If it is an element, assign it directly
        this.editorRoot = selectorOrElement;
      } else {
        // If it is a selector, tries to find element
        const editorRoot = document.querySelector(selectorOrElement);

        // If an element is found using this selector,
        // assign this element as the root element
        if (editorRoot) {
          this.editorRoot = editorRoot;
        }
      }

      this.opts = opts;
      this.startEditor();
    }

    startEditor() {
      const isCSSInjected = inject_css(editor_css, null, this.opts.styleParent);
      
      if (!isCSSInjected) {
        throw Error('Failed to inject CodeFlask CSS.');
        return;
      }

      // The order matters (pre > code). Don't change it
      // or things are going to break.
      this.createWrapper();
      this.createTextarea();
      this.createPre();
      this.createCode();

      this.runOptions();
      this.listenTextarea();
      this.populateDefault();
      this.updateCode(this.code);
    }

    createWrapper() {
      this.code = this.editorRoot.innerHTML;
      this.editorRoot.innerHTML = '';
      this.elWrapper = this.createElement('div', this.editorRoot);
      this.elWrapper.classList.add('codeflask');
    }

    createTextarea() {
      this.elTextarea = this.createElement('textarea', this.elWrapper);
      this.elTextarea.classList.add('codeflask__textarea', 'codeflask__flatten');
    }

    createPre() {
      this.elPre = this.createElement('pre', this.elWrapper);
      this.elPre.classList.add('codeflask__pre', 'codeflask__flatten');
    }

    createCode() {
      this.elCode = this.createElement('code', this.elPre);
      this.elCode.classList.add('codeflask__code', `language-${this.opts.language || 'html'}`);
    }

    createLineNumbers() {
      this.elLineNumbers = this.createElement('div', this.elWrapper);
      this.elLineNumbers.classList.add('codeflask__lines');
      this.setLineNumber();
    }

    createElement(elementTag, whereToAppend) {
      const element = document.createElement(elementTag);
      whereToAppend.appendChild(element);

      return element;
    }

    runOptions() {
      this.opts.rtl = this.opts.rtl || false;
      this.opts.tabSize = this.opts.tabSize || 2;
      this.opts.enableAutocorrect = this.opts.enableAutocorrect || false;
      this.opts.lineNumbers = this.opts.lineNumbers || false;
      this.opts.defaultTheme = this.opts.defaultTheme !== false;
      this.opts.areaId = this.opts.areaId || null;
      this.opts.ariaLabelledby = this.opts.ariaLabelledby || null;

      // if handleTabs is not either true or false, make it true by default
      if (typeof this.opts.handleTabs !== 'boolean') {
        this.opts.handleTabs = true;
      }

      if (this.opts.rtl === true) {
        this.elTextarea.setAttribute('dir', 'rtl');
        this.elPre.setAttribute('dir', 'rtl');
      }

      if (this.opts.enableAutocorrect === false) {
        this.elTextarea.setAttribute('spellcheck', 'false');
        this.elTextarea.setAttribute('autocapitalize', 'off');
        this.elTextarea.setAttribute('autocomplete', 'off');
        this.elTextarea.setAttribute('autocorrect', 'off');
      }

      if (this.opts.lineNumbers) {
        this.elWrapper.classList.add('codeflask--has-line-numbers');
        this.createLineNumbers();
      }

      if (this.opts.defaultTheme) {
        inject_css(default_css_theme, 'theme-default', this.opts.styleParent);
      }

      if (this.opts.areaId) {
        this.elTextarea.setAttribute('id', this.opts.areaId);
      }

      if (this.opts.ariaLabelledby) {
        this.elTextarea.setAttribute('aria-labelledby', this.opts.ariaLabelledby);
      }
    }

    updateLineNumbersCount() {
      let numberList = '';

      for (let i = 1; i <= this.lineNumber; i++) {
        numberList = numberList + `<span class="codeflask__lines__line">${i}</span>`;
      }

      this.elLineNumbers.innerHTML = numberList;
    }

    listenTextarea() {
      this.elTextarea.addEventListener('input', (e) => {
        this.code = e.target.value;
        this.elCode.innerHTML = escape_html(e.target.value);
        this.highlight();
        setTimeout(() => {
          this.runUpdate();
          this.setLineNumber();
        }, 1);

      });

      this.elTextarea.addEventListener('keydown', (e) => {
        this.handleTabs(e);
        this.handleSelfClosingCharacters(e);
        this.handleNewLineIndentation(e);
      });

      this.elTextarea.addEventListener('scroll', (e) => {
        this.elPre.style.transform = `translate3d(-${e.target.scrollLeft}px, -${e.target.scrollTop}px, 0)`;
        if (this.elLineNumbers) {
          this.elLineNumbers.style.transform = `translate3d(0, -${e.target.scrollTop}px, 0)`;
        }
      });
    }

    handleTabs(e) {
      if (this.opts.handleTabs) {
        if (e.keyCode !== 9) {
          return;
        }
        e.preventDefault();
        const pressedCode = e.keyCode;
        const selectionStart = this.elTextarea.selectionStart;
        const selectionEnd = this.elTextarea.selectionEnd;
        const newCode = `${this.code.substring(0, selectionStart)}${' '.repeat(this.opts.tabSize)}${this.code.substring(selectionEnd)}`;

        this.updateCode(newCode);
        this.elTextarea.selectionEnd = selectionEnd + this.opts.tabSize;
      }
    }

    handleSelfClosingCharacters(e) {
      const openChars = ['(', '[', '{', '<'];
      const key = e.key;

      if (!openChars.includes(key)) {
        return;
      }

      switch(key) {
        case '(':
        this.closeCharacter(')');
        break;

        case '[':
        this.closeCharacter(']');
        break;

        case '{':
        this.closeCharacter('}');
        break;

        case '<':
        this.closeCharacter('>');
        break;
      }
    }

    setLineNumber() {
      this.lineNumber = this.code.split('\n').length;

      if (this.opts.lineNumbers) {
        this.updateLineNumbersCount();
      }
    }

    handleNewLineIndentation(e) {
      if (e.keyCode !== 13) {
        return;
      }
      // TODO: Make this shit work right

      // const selectionStart = this.elTextarea.selectionStart;
      // const selectionEnd = this.elTextarea.selectionEnd;
      // const allLines = this.code.split('\n').length;
      // const lines = this.code.substring(0, selectionStart).split('\n');
      // const currentLine = lines.length;
      // const lastLine = lines[currentLine - 1];

      // console.log(currentLine, allLines);

      // if (lastLine !== undefined && currentLine < allLines) {
      //   e.preventDefault();
      //   const spaces = lastLine.match(/^ {1,}/);

      //   if (spaces) {
      //     console.log(spaces[0].length);
      //     const newCode = `${this.code.substring(0, selectionStart)}\n${' '.repeat(spaces[0].length)}${this.code.substring(selectionEnd)}`;
      //     this.updateCode(newCode);
      //     setTimeout(() => {
      //       this.elTextarea.selectionEnd = selectionEnd + spaces[0].length + 1;
      //     }, 0);
      //   }
      // }
    }

    closeCharacter(closeChar) {
      const selectionStart = this.elTextarea.selectionStart;
      const selectionEnd = this.elTextarea.selectionEnd;
      const newCode = `${this.code.substring(0, selectionStart)}${closeChar}${this.code.substring(selectionEnd)}`;

      this.updateCode(newCode);
      this.elTextarea.selectionEnd = selectionEnd;
    }

    updateCode(newCode) {
      this.code = newCode;
      this.elTextarea.value = newCode;
      this.elCode.innerHTML = escape_html(newCode);
      this.highlight();
      setTimeout(this.runUpdate.bind(this), 1);
    }

    updateLanguage(newLanguage) {
      const oldLanguage = this.opts.language;
      this.elCode.classList.remove(`language-${oldLanguage}`);
      this.elCode.classList.add(`language-${newLanguage}`);
      this.opts.language = newLanguage;
      this.highlight();
    }

    addLanguage(name, options) {
      prism.languages[name] = options;
    }

    populateDefault() {
      this.updateCode(this.code);
    }

    highlight() {
      prism.highlightElement(this.elCode, false);
    }

    onUpdate(callback) {
      if (callback && {}.toString.call(callback) !== '[object Function]') {
        throw Error('CodeFlask expects callback of type Function');
        return;
      }

      this.updateCallBack = callback;
    }

    getCode() {
      return this.code;
    }

    runUpdate() {
      if (this.updateCallBack) {
        this.updateCallBack(this.code);
      }
    }
  }

  return CodeFlask;

})));
